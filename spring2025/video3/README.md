# Video 3 - Introduction to Assembly Language

This directory contains introductory x86-64 assembly programming examples, covering basic operations, data sections, control flow, and the compilation process.

## Contents

### First Assembly Programs
- **firstas.s** - Very first assembly program (basic structure)
- **firstascommented.s** - Commented version explaining assembly basics
- **hello.s** - "Hello World" generated by gcc -S from hello.c
- **hellocommented.s** - Detailed explanation of compiler-generated assembly
- **hello.c** - Source C file for comparison

### Arithmetic Operations
- **add1.s** - Addition operation example
- **add1commented.s** - Explains ADD instruction and register usage
- **sub1.s** - Subtraction operation example
- **sub1commented.s** - Explains SUB instruction

### Data Sections
- **data0.s** - Basic data section with variables
- **data0commented.s** - Explains .data and .rodata sections
- **data1.s** - Accessing global variables (absolute addressing)
- **data1commented.s** - Detailed explanation of data access
- **data2.s** - RIP-relative addressing for data
- **data2commented.s** - Explains position-independent code

### Comparison and Control Flow
- **cmp1.s** - Basic comparison with conditional jump
- **cmp1commented.s** - Explains CMP and conditional jumps
- **cmp2.s** - Multiple comparisons
- **cmp2commented.s** - More complex comparison patterns
- **cmp3.s** - Different comparison scenarios
- **cmp3commented.s** - Detailed conditional logic
- **cmp4.s** - Additional comparison example
- **cmp4commented.s** - Advanced comparison patterns

### Loops
- **loop1.s** - Basic loop using jump and compare
- **loop1commented.s** - Explains loop construction in assembly

### Lecture Notes
- **Agenda.org** - Comprehensive notes on compilation, registers, and assembly basics

## Compilation

### Basic Assembly Compilation

**Assemble and link:**
```bash
# For any .s file without external dependencies:
as firstas.s -o firstas.o   # Assemble to object file
ld firstas.o -o firstas     # Link to executable
./firstas                    # Run
```

### Compile All Examples

```bash
# Compile all assembly programs
for f in firstas add1 sub1 data0 data1 data2 cmp1 cmp2 cmp3 cmp4 loop1; do
  as ${f}.s -o ${f}.o
  ld ${f}.o -o ${f}
done
```

### Generate Assembly from C

```bash
# See how C compiles to assembly
gcc -S hello.c              # Generates hello.s
gcc -S -O0 hello.c          # No optimization (easier to read)
gcc -S -O2 hello.c          # With optimization (more efficient)
```

### Check Exit Codes

```bash
# Run program and check its exit code
./firstas
echo $?  # Prints the exit code (0-255)
```

### View Binary Content

```bash
# See the raw bytes of the executable
xxd firstas | head          # Hexadecimal dump
objdump -d firstas          # Disassemble to see instructions
```

## Running the Examples

### firstas - Basic Program

**Run:**
```bash
./firstas
echo $?
```

**Expected behavior:**
- Program exits immediately
- Returns exit code (check with `echo $?`)
- Demonstrates minimal program structure

**Expected exit code:**
```
0  (or whatever value is set in the program)
```

### add1 / sub1 - Arithmetic

**Run:**
```bash
./add1
echo $?
```

**Expected behavior:**
- Performs arithmetic operation
- Result typically stored in register
- May exit with result as exit code

### data0, data1, data2 - Data Access

**Run:**
```bash
./data1
```

**Expected behavior:**
- Accesses global variables from .data section
- May print values using syscalls
- Demonstrates different addressing modes

### cmp1, cmp2, cmp3, cmp4 - Comparisons

**Run:**
```bash
./cmp1
```

**Expected behavior:**
- Compares values using CMP instruction
- Takes conditional branch based on result
- Different exit codes based on comparison

### loop1 - Loops

**Run:**
```bash
./loop1
```

**Expected behavior:**
- Executes loop using JMP and conditional jumps
- Counter in register decrements or increments
- Exits when loop condition becomes false

**What it demonstrates:**
- How to construct loops without 'for' or 'while'
- Manual counter management
- Conditional vs unconditional jumps

## Key Concepts Demonstrated

### Assembly Language Basics

**What is Assembly?**
- Low-level programming language
- Nearly 1:1 mapping to machine code
- Human-readable representation of CPU instructions
- Architecture-specific (this course uses x86-64)

**Assembler vs Compiler:**
- **Assembler** (as): Translates assembly to machine code
- **Compiler** (gcc): Translates C to assembly, then assembles
- Different assemblers have different syntax (AT&T vs Intel)

### AT&T Syntax (GNU Assembler)

**Used in this directory:**
- Source comes before destination: `mov $5, %rax` (move 5 into rax)
- Register names prefixed with %: `%rax`, `%rbx`
- Immediate values prefixed with $: `$10`, `$0`
- Harder to read than Intel syntax
- Default in GCC and GDB

**Intel Syntax (alternative):**
- Destination before source: `mov rax, 5`
- No prefix symbols
- More readable for humans
- Used by NASM assembler

### Registers (from Agenda)

**16 General-Purpose Registers on x86-64:**
- **%rax** - Accumulator (return values, syscall numbers)
- **%rbx** - Base register
- **%rcx** - Counter (loop counters)
- **%rdx** - Data register
- **%rsi** - Source index
- **%rdi** - Destination index (first argument in function calls)
- **%rbp** - Base pointer (stack frames)
- **%rsp** - Stack pointer (top of stack)
- **%r8 - %r15** - Additional general-purpose registers
- **%rip** - Instruction pointer (program counter, special use)

**Register Characteristics:**
- Each holds 64 bits (8 bytes)
- Fastest memory on the system (single clock cycle access)
- Limited quantity: only 128 bytes total!
- Memory is 10,000-100,000x slower

### Program Sections

**`.section .text`:**
- Contains executable code
- All instructions go here
- Read-only at runtime
- Entry point marked with `_start`

**`.section .data`:**
- Contains initialized writable data
- Global variables with initial values
- Persists for program lifetime

**`.section .rodata`:**
- Read-only data
- String literals, constants
- Cannot be modified at runtime

**`.section .bss`:**
- Uninitialized data
- Zero-initialized automatically
- Saves space in executable

### Basic Instructions

**Data Movement:**
```assembly
mov $5, %rax        # Move immediate value 5 into rax
mov %rax, %rbx      # Copy rax to rbx
```

**Arithmetic:**
```assembly
add $10, %rax       # rax = rax + 10
sub %rbx, %rax      # rax = rax - rbx
inc %rax            # rax = rax + 1
dec %rax            # rax = rax - 1
```

**Comparison:**
```assembly
cmp $10, %rax       # Compare rax with 10 (sets flags)
```

**Jumps (Unconditional):**
```assembly
jmp label           # Always jump to label
```

**Conditional Jumps (after CMP):**
```assembly
je label            # Jump if equal (zero flag set)
jne label           # Jump if not equal
jl label            # Jump if less (signed)
jle label           # Jump if less or equal
jg label            # Jump if greater (signed)
jge label           # Jump if greater or equal
```

**System Calls:**
```assembly
mov $60, %rax       # Syscall number (60 = exit)
xor %rdi, %rdi      # Exit code (0)
syscall             # Make system call
```

### Addressing Modes

**Immediate:**
```assembly
mov $42, %rax       # Value 42
```

**Register:**
```assembly
mov %rbx, %rax      # Value in rbx
```

**Absolute:**
```assembly
mov myvar, %rax     # Value at address myvar
```

**RIP-Relative (Position Independent):**
```assembly
lea msg(%rip), %rsi # Address of msg relative to instruction pointer
```

### Control Flow

**Building a loop:**
```assembly
        mov $10, %rcx      # Counter = 10
loop_start:
        # Loop body here
        dec %rcx           # Decrement counter
        cmp $0, %rcx       # Compare with 0
        jne loop_start     # Jump if not equal (not zero)
        # Continue after loop
```

**Conditional execution:**
```assembly
        cmp $5, %rax       # Compare rax with 5
        jl less_than       # Jump if rax < 5
        # rax >= 5 case
        jmp done
less_than:
        # rax < 5 case
done:
        # Continue
```

### System Calls

**Exit syscall:**
```assembly
mov $60, %rax       # Syscall 60 = exit
mov $0, %rdi        # Exit code
syscall
```

**Write syscall:**
```assembly
mov $1, %rax        # Syscall 1 = write
mov $1, %rdi        # File descriptor 1 = stdout
lea msg(%rip), %rsi # Buffer address
mov $13, %rdx       # Number of bytes
syscall
```

## Troubleshooting

### Segmentation Fault
```bash
# Common causes:
# 1. Missing _start label
# 2. Not exiting properly (must call exit syscall)
# 3. Accessing invalid memory addresses
# 4. Incorrect syscall parameters

# Debug with gdb:
gdb ./firstas
(gdb) layout asm    # Show assembly
(gdb) layout regs   # Show registers
(gdb) stepi         # Step one instruction
(gdb) info registers # Show all registers
```

### Program Doesn't Exit
```bash
# All assembly programs must explicitly exit:
mov $60, %rax       # exit syscall
xor %rdi, %rdi      # exit code 0
syscall

# Or use a different exit code:
mov $60, %rax
mov $42, %rdi       # exit code 42
syscall
```

### Syntax Errors
```bash
# Common mistakes:
# 1. Forgetting $ for immediate values: mov 5, %rax ❌  mov $5, %rax ✓
# 2. Forgetting % for registers: mov 5, rax ❌  mov $5, %rax ✓
# 3. Wrong operand order (source, dest): mov %rax, $5 ❌  mov $5, %rax ✓
# 4. Missing colons on labels: mylabel ❌  mylabel: ✓
```

### Wrong Exit Code
```bash
# Check what exit code your program returns:
./firstas
echo $?

# Remember: exit codes are 0-255
# Values > 255 wrap around (256 becomes 0)
```

## Notes

- All examples use AT&T syntax (default for GNU assembler)
- Assembly is architecture-specific (x86-64 here)
- Understanding assembly helps with:
  - Debugging C programs
  - Performance optimization
  - Reverse engineering
  - Embedded systems
  - Compiler development
- Commented versions provide extensive educational detail
- hello.s shows what GCC actually generates (includes compiler boilerplate)
- The Agenda.org provides context on why assembly matters
- Modern compilers generate better assembly than humans for complex code
- But assembly is essential for certain tasks (OS kernels, bootloaders, etc.)
- GDB uses AT&T syntax by default: `set disassembly-flavor intel` to change

## Comparison: C vs Assembly

**C code (hello.c):**
```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

**Assembly equivalent (simplified):**
```assembly
.section .rodata
msg: .string "Hello, world!\n"

.section .text
.global _start

_start:
    # write syscall
    mov $1, %rax
    mov $1, %rdi
    lea msg(%rip), %rsi
    mov $14, %rdx
    syscall

    # exit syscall
    mov $60, %rax
    xor %rdi, %rdi
    syscall
```

## Learning Path

1. **Start here:** firstas.s - Basic structure
2. **Data movement:** add1.s, sub1.s - Arithmetic
3. **Data sections:** data0.s, data1.s, data2.s - Variables
4. **Control flow:** cmp1.s - Conditionals
5. **Loops:** loop1.s - Iteration
6. **Real code:** hello.s - What compilers generate

## Related Topics

See also:
- `/home/user/cs201/spring2025/assembly/` - Advanced assembly with functions and recursion
- `/home/user/cs201/spring2025/video1/` - C basics to compare
- `/home/user/cs201/spring2025/video2/` - How data is represented
- GDB tutorial - Debugging assembly code
- Intel x86-64 documentation - Complete instruction set reference
