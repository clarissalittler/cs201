* Agenda
** what happens when you compile, really?
Instructions in one language are being turned into a series of instructions in the assembly language of the processor

...sort of

Each processor has a instruction set. An instruction set is actually just a specification of a sequence of bytes and this sequence of bytes gets interpreted as a operation at the level of the physical hardware

Assembly is not just "a" language, not even for a specific instruction set, but like a family of dialects defined by the *assembler*.

assembler: the thing that takes the code you write in assembly (or the code generated by a compiler) and then turns it into the sequence of bytes for the instruction set

assemblers have different syntax and different features

on linux:
 + gnu assembler (=as= on your command line) <-- AT&T syntax, harder to read, *but* it's the syntax that gdb uses by default
 + nasm (netwide assembler) <-- arguably way more fun to use, Intel syntax
** looking at hex
xxd
** looking at the source
gcc -S
** what are registers? where do they live?
 registers (register file) the lowest level memory on your machine

 the registers are on each core

 16 of them in x86-64 (excluding special ones like floating point and vector registers and %rip)
 Basic registers
 + =%rax=: accumulator register (for operations like mul, div, etc.)
 + =%rbx=: base register (historically used for array base address)
 + =%rcx=: counter register (used in loops and rep instructions)
 + =%rdx=: data register (used in I/O operations, multiplication, and division)
 + =%rsi=: source index for string operations
 + =%rdi=: destination index for string operations
 + =%rbp=: base pointer (often used to point to function stack frames)
 + =%rsp=: stack pointer (points to top of the stack)
 + =%r8= â€“ =%r15=: additional general-purpose registers
 + =%rip= (special case, you won't use it except in rip-relative addressing)

** x86-64 assembly
 just x86-64 assembly in this class because it's what is common on most laptops and desktops **at the moment**
*** other instruction sets
 + ARM (actually a bunch of versions)
   + small single board computers
   + cell phones
   + apple machines
 + RISCV
   + open source
   + not used in much!
   + ...but that could change faaaast
** why learn assembly?
 + because we can
 + because learning the guts of things is fun
 + because it's good experience
 + because when you need it, you really need it
 + if you do any kind of compiler writing, high-performance computing, secure computing or cybersecurity, reverse engineering, &c. you really need to know assembly
** our very first program
whoops why'd that crash?
*** fixing it
*** return codes
** DONE a proper first program
** arithmetic operations
** what are global variables
** accessing global variables
*** absolute address
*** rip-relative address
** jmp, cmp, and how to write a loop
