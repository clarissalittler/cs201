#+title:      Concurrency and Parallelism in C
#+date:       [2025-05-11 Sun]
#+filetags:   :concurrency:systems:processes:threads:ipc:synchronization:

* Goals of this document
This document provides a comprehensive guide to concurrency and parallelism in Unix-like systems through C programming. It covers processes, threads, synchronization, and inter-process communication (IPC) mechanisms with practical examples.

* Introduction to Concurrency
** What is concurrency?
Concurrency is the ability of a system to handle multiple tasks that overlap in time. In computing, it refers to multiple computations happening at the same time. This can be achieved through various mechanisms like processes, threads, or even asynchronous I/O.

Concurrency doesn't necessarily mean that tasks are executing simultaneously (true parallelism). Instead, it means that progress is being made on multiple tasks, possibly by interleaving their execution.

** Why is concurrency important?
- Improved resource utilization (CPU, I/O, etc.)
- Better responsiveness in interactive applications
- Ability to handle multiple client connections in servers
- Natural modeling of real-world concurrent activities
- Taking advantage of multi-core processors (parallelism)

** Concurrency vs. Parallelism
While often used interchangeably, they have distinct meanings:

- *Concurrency*: Dealing with multiple tasks during overlapping time periods by interleaving their execution
- *Parallelism*: Executing multiple tasks simultaneously, typically on multiple CPU cores

Think of concurrency as juggling multiple balls (you're only holding one at a time, but making progress on all), while parallelism is like having multiple people each juggling their own ball.

* Processes
** What is a process?
A process is an instance of a program in execution. Each process has its own:
- Address space (memory allocation)
- Program counter
- Register set
- Stack
- Heap
- File descriptors
- Signal handlers

Processes are isolated from each other by default, which provides security and stability (one crashing process doesn't affect others).

** Process Creation: fork()
In Unix-like systems, processes are created using the =fork()= system call. When a process calls =fork()=, the operating system creates a new process by duplicating the calling process. The new process is called the child, while the original process is called the parent.

=fork()= returns:
- To the parent process: the PID of the child process
- To the child process: 0
- -1 if the creation of a child process was unsuccessful

*** Basic fork example
#+begin_src c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        // Fork failed
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process
        printf("Child process: My PID is %d, my parent's PID is %d\n", 
               getpid(), getppid());
    } else {
        // Parent process
        printf("Parent process: My PID is %d, my child's PID is %d\n", 
               getpid(), pid);
    }
    
    return 0;
}
#+end_src

*** Key points about fork()
- After fork(), both processes continue execution from the next instruction
- Child inherits copies of the parent's:
  - Open file descriptors
  - Signal handlers
  - Environment variables
  - Current working directory
  - Resource limits
- Memory is typically copied-on-write for efficiency
- Variables with the same names exist in both processes but are separate copies

** Process Execution: exec family
The =exec= family of functions replaces the current process image with a new one. Common variants:
- =execl()=: List of arguments
- =execv()=: Vector of arguments
- =execle()=: List of arguments and environment
- =execve()=: Vector of arguments and environment

Example:
#+begin_src c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("Child about to execute ls command...\n");
        execl("/bin/ls", "ls", "-l", NULL);
        // The following will only execute if execl fails
        perror("execl failed");
        return 1;
    } else if (pid > 0) {
        // Parent process
        printf("Parent created child with PID %d\n", pid);
    }
    
    return 0;
}
#+end_src

** Process Termination and Waiting
Processes terminate by:
- Returning from main
- Calling =exit()=
- Receiving certain signals (like SIGTERM)

Parents can wait for children using:
- =wait()=: Waits for any child
- =waitpid()=: Waits for a specific child

Example:
#+begin_src c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("Child executing...\n");
        sleep(2);
        exit(42);  // Exit with status 42
    } else {
        // Parent process
        int status;
        printf("Parent waiting for child...\n");
        waitpid(pid, &status, 0);
        
        if (WIFEXITED(status)) {
            printf("Child exited with status %d\n", WEXITSTATUS(status));
        }
    }
    
    return 0;
}
#+end_src

** Zombie and Orphan Processes
- *Zombie process*: A child that has terminated but its parent hasn't called =wait()= to collect its exit status
- *Orphan process*: A child whose parent has terminated before it; adopted by the init process (PID 1)

* Threads
** What are threads?
Threads are "lightweight processes" that exist within a process. All threads within a process share:
- The same address space (code, data, heap)
- Open file descriptors
- Signal handlers

Each thread has its own:
- Thread ID
- Program counter
- Register set
- Stack

** Thread Creation: pthread_create()
POSIX threads (pthreads) is a standardized API for thread creation and synchronization.

Basic thread creation:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

void* thread_function(void* arg) {
    printf("Thread executing with argument: %s\n", (char*)arg);
    return NULL;
}

int main() {
    pthread_t thread;
    char* message = "Hello from main thread";
    
    // Create a new thread
    if (pthread_create(&thread, NULL, thread_function, message) != 0) {
        perror("Thread creation failed");
        return 1;
    }
    
    // Wait for thread to complete
    pthread_join(thread, NULL);
    printf("Thread joined\n");
    
    return 0;
}
#+end_src

** Thread Termination and Joining
Threads terminate by:
- Returning from the thread function
- Calling =pthread_exit()=
- The entire process exiting

Thread joining:
- =pthread_join()=: Wait for a thread to terminate
- =pthread_detach()=: Mark a thread as detached, resources automatically reclaimed

** Thread vs Process Advantages
*** Thread advantages:
- Faster creation and termination
- Easier sharing of data
- Lower memory overhead
- Faster context switching

*** Process advantages:
- Better isolation and protection
- Easier to implement
- More portable
- Crash of one process doesn't affect others

* Thread Synchronization
** The Need for Synchronization
When multiple threads access shared data, race conditions can occur, leading to inconsistent results. Synchronization mechanisms help ensure orderly access to shared resources.

** Race Condition Example
Consider a simple counter increment:
#+begin_src c
int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 1000; i++) {
        counter++; // This is not atomic!
    }
    return NULL;
}
#+end_src

The operation =counter++= actually involves three steps:
1. Read the current value of counter
2. Increment the value
3. Store the new value back

If two threads execute this concurrently, they might interleave these steps, leading to lost updates.

** Mutexes (Mutual Exclusion)
Mutexes ensure that only one thread can access a critical section at a time.

Basic mutex usage:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

int counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* increment(void* arg) {
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;  // Critical section
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, increment, NULL);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("Final counter value: %d\n", counter);
    return 0;
}
#+end_src

** Condition Variables
Condition variables allow threads to wait until a specific condition occurs. They are used with mutexes.

Example:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int ready = 0;

void* producer(void* arg) {
    pthread_mutex_lock(&mutex);
    
    // Do some work to produce data
    printf("Producer: Working...\n");
    sleep(2);
    
    // Set the condition and signal
    ready = 1;
    printf("Producer: Data is ready!\n");
    pthread_cond_signal(&cond);
    
    pthread_mutex_unlock(&mutex);
    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    
    // Wait until data is ready
    while (!ready) {
        printf("Consumer: Waiting for data...\n");
        pthread_cond_wait(&cond, &mutex);
    }
    
    // Process the data
    printf("Consumer: Processing data\n");
    
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;
    
    pthread_create(&cons_thread, NULL, consumer, NULL);
    sleep(1);  // Ensure consumer starts first
    pthread_create(&prod_thread, NULL, producer, NULL);
    
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);
    
    return 0;
}
#+end_src

** Semaphores
Semaphores are counters that control access to shared resources. They can be used for:
- Mutual exclusion (binary semaphore)
- Resource counting (counting semaphore)

Example:
#+begin_src c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_ITEMS 10
#define BUFFER_SIZE 5

sem_t empty;
sem_t full;
sem_t mutex;
int buffer[BUFFER_SIZE];
int in = 0, out = 0;

void* producer(void* arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        int item = i + 1;
        
        sem_wait(&empty);  // Wait for empty slot
        sem_wait(&mutex);  // Enter critical section
        
        buffer[in] = item;
        printf("Producer: Inserted item %d at position %d\n", item, in);
        in = (in + 1) % BUFFER_SIZE;
        
        sem_post(&mutex);  // Exit critical section
        sem_post(&full);   // Signal item produced
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        sem_wait(&full);   // Wait for an item
        sem_wait(&mutex);  // Enter critical section
        
        int item = buffer[out];
        printf("Consumer: Removed item %d from position %d\n", item, out);
        out = (out + 1) % BUFFER_SIZE;
        
        sem_post(&mutex);  // Exit critical section
        sem_post(&empty);  // Signal slot emptied
    }
    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;
    
    sem_init(&empty, 0, BUFFER_SIZE);  // Buffer starts empty
    sem_init(&full, 0, 0);             // Buffer starts with no items
    sem_init(&mutex, 0, 1);            // Binary semaphore for CS
    
    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);
    
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);
    
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);
    
    return 0;
}
#+end_src

** Deadlocks
Deadlocks occur when threads are blocked forever waiting for each other. The classic example is the dining philosophers problem.

Four conditions for deadlock:
1. Mutual exclusion: Resources that cannot be shared
2. Hold and wait: A thread holds resources while waiting for others
3. No preemption: Resources cannot be forcibly taken away
4. Circular wait: A cycle of threads, each waiting for a resource held by the next

Example (deadlock-prone):
#+begin_src c
void* thread1_function(void* arg) {
    pthread_mutex_lock(&mutex1);
    sleep(1);  // Increases chance of deadlock
    pthread_mutex_lock(&mutex2);
    
    // Critical section
    
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2_function(void* arg) {
    pthread_mutex_lock(&mutex2);
    sleep(1);  // Increases chance of deadlock
    pthread_mutex_lock(&mutex1);
    
    // Critical section
    
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}
#+end_src

Deadlock prevention includes:
- Lock ordering (always acquire locks in the same order)
- Lock timeouts
- Deadlock detection
- Using lock-free data structures

* Inter-Process Communication (IPC)
** What is IPC?
IPC mechanisms allow processes to communicate and synchronize their actions. Unlike threads, processes don't share memory by default, so explicit IPC mechanisms are needed.

** Pipes
Pipes provide a one-way communication channel between related processes (typically parent and child).

Example:
#+begin_src c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];  // pipefd[0] is read end, pipefd[1] is write end
    pid_t pid;
    char message[] = "Hello from the parent!";
    char buffer[100];
    
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }
    
    pid = fork();
    
    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {  // Child process
        close(pipefd[1]);  // Close unused write end
        
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        
        close(pipefd[0]);
    } else {  // Parent process
        close(pipefd[0]);  // Close unused read end
        
        write(pipefd[1], message, strlen(message) + 1);
        
        close(pipefd[1]);
        wait(NULL);  // Wait for child to finish
    }
    
    return 0;
}
#+end_src

** Named Pipes (FIFOs)
Named pipes (FIFOs) allow communication between unrelated processes.

Example (writer):
#+begin_src c
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd;
    char message[] = "Hello via FIFO!";
    
    // Create the named pipe (FIFO)
    mkfifo("/tmp/myfifo", 0666);
    
    // Open the FIFO for writing
    fd = open("/tmp/myfifo", O_WRONLY);
    
    // Write to the FIFO
    write(fd, message, strlen(message) + 1);
    
    // Close the FIFO
    close(fd);
    
    return 0;
}
#+end_src

Example (reader):
#+begin_src c
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    int fd;
    char buffer[100];
    
    // Open the FIFO for reading
    fd = open("/tmp/myfifo", O_RDONLY);
    
    // Read from the FIFO
    read(fd, buffer, sizeof(buffer));
    printf("Received message: %s\n", buffer);
    
    // Close the FIFO
    close(fd);
    
    return 0;
}
#+end_src

** Message Queues
Message queues allow processes to send structured messages to each other.

Example:
#+begin_src c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

// Message structure
struct msg_buffer {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key = ftok("progfile", 65);
    int msgid = msgget(key, 0666 | IPC_CREAT);
    struct msg_buffer message;
    
    // Sender
    message.msg_type = 1;
    strcpy(message.msg_text, "Hello from message queue!");
    msgsnd(msgid, &message, sizeof(message), 0);
    
    // Receiver (in real applications, this would be in a different process)
    msgrcv(msgid, &message, sizeof(message), 1, 0);
    printf("Received: %s\n", message.msg_text);
    
    // Destroy the message queue
    msgctl(msgid, IPC_RMID, NULL);
    
    return 0;
}
#+end_src

** Shared Memory
Shared memory allows multiple processes to access a common region of memory.

Example:
#+begin_src c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>
#include <unistd.h>

int main() {
    key_t key = ftok("shmfile", 65);
    int shmid = shmget(key, 1024, 0666|IPC_CREAT);
    char *str = (char*) shmat(shmid, NULL, 0);
    
    if (fork() == 0) {  // Child process
        sleep(1);  // Ensure parent writes first
        printf("Child read: %s\n", str);
        shmdt(str);
    } else {  // Parent process
        strcpy(str, "Hello from shared memory!");
        printf("Parent wrote message to shared memory\n");
        wait(NULL);  // Wait for child
        shmdt(str);
        shmctl(shmid, IPC_RMID, NULL);  // Destroy shared memory
    }
    
    return 0;
}
#+end_src

** Sockets
Sockets provide network and inter-process communication. They can be used for processes on the same machine or across different machines.

Example (local Unix domain socket):
#+begin_src c
// Server code
#include <stdio.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <string.h>

int main() {
    int server_fd, client_fd;
    struct sockaddr_un address;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    char *message = "Hello from server";
    
    // Create socket
    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    
    address.sun_family = AF_UNIX;
    strcpy(address.sun_path, "/tmp/socket");
    unlink("/tmp/socket");  // Remove if it already exists
    
    // Bind socket
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    
    // Listen for connections
    listen(server_fd, 3);
    
    // Accept connection
    client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
    
    // Read client message
    read(client_fd, buffer, 1024);
    printf("Client: %s\n", buffer);
    
    // Send response
    send(client_fd, message, strlen(message), 0);
    
    close(client_fd);
    close(server_fd);
    return 0;
}
#+end_src

* Common Concurrency Patterns
** Producer-Consumer
The producer-consumer pattern involves two types of threads/processes:
- Producers generate data
- Consumers process the data

A bounded buffer is used to transfer data between them, with synchronization to ensure the buffer doesn't overflow or underflow.

** Reader-Writer
The reader-writer pattern allows multiple threads to read simultaneously, but requires exclusive access for writing. Used when reads are more common than writes.

** Thread Pool
A thread pool maintains a set of worker threads ready to execute tasks. This avoids the overhead of creating and destroying threads for each task.

Example:
#+begin_src c
// Simplified thread pool example
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

#define POOL_SIZE 3
#define QUEUE_SIZE 10

// Task structure
typedef struct {
    void (*function)(void*);
    void* argument;
} Task;

// Thread pool structure
typedef struct {
    Task taskQueue[QUEUE_SIZE];
    int front, rear, count;
    pthread_t workers[POOL_SIZE];
    pthread_mutex_t queueMutex;
    pthread_cond_t queueNotEmpty;
    pthread_cond_t queueNotFull;
    int shutdown;
} ThreadPool;

ThreadPool* pool;

// Worker thread function
void* worker(void* arg) {
    while (1) {
        pthread_mutex_lock(&pool->queueMutex);
        
        // Wait for work if queue is empty
        while (pool->count == 0 && !pool->shutdown) {
            pthread_cond_wait(&pool->queueNotEmpty, &pool->queueMutex);
        }
        
        // Exit if shutting down and queue is empty
        if (pool->shutdown && pool->count == 0) {
            pthread_mutex_unlock(&pool->queueMutex);
            pthread_exit(NULL);
        }
        
        // Get task from queue
        Task task = pool->taskQueue[pool->front];
        pool->front = (pool->front + 1) % QUEUE_SIZE;
        pool->count--;
        
        // Signal that queue is not full anymore
        pthread_cond_signal(&pool->queueNotFull);
        pthread_mutex_unlock(&pool->queueMutex);
        
        // Execute task
        (*(task.function))(task.argument);
    }
    
    return NULL;
}

// Initialize thread pool
void threadPoolInit() {
    pool = (ThreadPool*)malloc(sizeof(ThreadPool));
    pool->front = pool->rear = pool->count = 0;
    pool->shutdown = 0;
    
    pthread_mutex_init(&pool->queueMutex, NULL);
    pthread_cond_init(&pool->queueNotEmpty, NULL);
    pthread_cond_init(&pool->queueNotFull, NULL);
    
    // Create worker threads
    for (int i = 0; i < POOL_SIZE; i++) {
        pthread_create(&pool->workers[i], NULL, worker, NULL);
    }
}

// Add task to thread pool
void threadPoolAdd(void (*function)(void*), void* argument) {
    pthread_mutex_lock(&pool->queueMutex);
    
    // Wait if queue is full
    while (pool->count == QUEUE_SIZE) {
        pthread_cond_wait(&pool->queueNotFull, &pool->queueMutex);
    }
    
    // Add task to queue
    Task task = {function, argument};
    pool->taskQueue[pool->rear] = task;
    pool->rear = (pool->rear + 1) % QUEUE_SIZE;
    pool->count++;
    
    // Signal that queue is not empty
    pthread_cond_signal(&pool->queueNotEmpty);
    pthread_mutex_unlock(&pool->queueMutex);
}

// Shutdown thread pool
void threadPoolShutdown() {
    pthread_mutex_lock(&pool->queueMutex);
    pool->shutdown = 1;
    pthread_mutex_unlock(&pool->queueMutex);
    
    // Wake up all worker threads
    pthread_cond_broadcast(&pool->queueNotEmpty);
    
    // Wait for all worker threads to finish
    for (int i = 0; i < POOL_SIZE; i++) {
        pthread_join(pool->workers[i], NULL);
    }
    
    // Clean up
    pthread_mutex_destroy(&pool->queueMutex);
    pthread_cond_destroy(&pool->queueNotEmpty);
    pthread_cond_destroy(&pool->queueNotFull);
    
    free(pool);
}
#+end_src

* Best Practices
** General Concurrency Guidelines
1. Keep critical sections small
2. Minimize shared data
3. Use higher-level abstractions when possible
4. Understand and avoid race conditions
5. Use thread-safe functions
6. Be aware of deadlocks
7. Prefer message passing over shared memory when appropriate
8. Test extensively with different timing and orderings

** Debugging Concurrent Programs
Debugging concurrent programs is challenging because:
- Bugs may be non-deterministic
- Traditional debugging can change timing and hide issues
- Race conditions can be difficult to reproduce

Techniques:
- Use logging with thread/process IDs
- Use tools like Valgrind, ThreadSanitizer, Helgrind
- Write deterministic tests
- Use assertions to check invariants

** Performance Considerations
1. Too many threads can lead to thrashing (context switching overhead)
2. Thread affinity can improve cache utilization
3. Understand the cost of synchronization
4. Consider the granularity of parallelism
5. Be aware of false sharing (when threads compete for the same cache line)

* Footnotes
[fn:1] POSIX (Portable Operating System Interface) is a family of standards for maintaining compatibility between operating systems. POSIX threading (pthreads) is the standardized threading API.

[fn:2] Compiling threaded programs in Linux requires linking with the pthread library: `gcc -pthread program.c -o program`