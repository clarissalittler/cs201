#+title:      Concurrency and Parallelism in C
#+date:       [2025-05-11 Sun]
#+filetags:   :concurrency:systems:processes:threads:ipc:synchronization:

* Goals of this document
This document provides a comprehensive guide to concurrency and parallelism in Unix-like systems through C programming. It covers processes, threads, synchronization, and inter-process communication (IPC) mechanisms with practical examples.

* Introduction to Concurrency
** What is concurrency?
Concurrency is the ability of a system to handle multiple tasks that overlap in time. In computing, it refers to multiple computations happening at the same time. This can be achieved through various mechanisms like processes, threads, or even asynchronous I/O.

Concurrency doesn't necessarily mean that tasks are executing simultaneously (true parallelism). Instead, it means that progress is being made on multiple tasks, possibly by interleaving their execution.

** Why is concurrency important?
- Improved resource utilization (CPU, I/O, etc.)
- Better responsiveness in interactive applications
- Ability to handle multiple client connections in servers
- Natural modeling of real-world concurrent activities
- Taking advantage of multi-core processors (parallelism)

** Concurrency vs. Parallelism
While often used interchangeably, they have distinct meanings:

- *Concurrency*: Dealing with multiple tasks during overlapping time periods by interleaving their execution
- *Parallelism*: Executing multiple tasks simultaneously, typically on multiple CPU cores

Think of concurrency as juggling multiple balls (you're only holding one at a time, but making progress on all), while parallelism is like having multiple people each juggling their own ball.

* Processes
** What is a process?
A process is an instance of a program in execution. Each process has its own:
- Address space (memory allocation)
- Program counter
- Register set
- Stack
- Heap
- File descriptors
- Signal handlers

Processes are isolated from each other by default, which provides security and stability (one crashing process doesn't affect others).

** Process Creation: fork()
In Unix-like systems, processes are created using the =fork()= system call. When a process calls =fork()=, the operating system creates a new process by duplicating the calling process. The new process is called the child, while the original process is called the parent.

=fork()= returns:
- To the parent process: the PID of the child process
- To the child process: 0
- -1 if the creation of a child process was unsuccessful

*** Basic fork example
#+begin_src c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid < 0) {
        // Fork failed
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process
        printf("Child process: My PID is %d, my parent's PID is %d\n", 
               getpid(), getppid());
    } else {
        // Parent process
        printf("Parent process: My PID is %d, my child's PID is %d\n", 
               getpid(), pid);
    }
    
    return 0;
}
#+end_src

*** Key points about fork()
- After fork(), both processes continue execution from the next instruction
- Child inherits copies of the parent's:
  - Open file descriptors
  - Signal handlers
  - Environment variables
  - Current working directory
  - Resource limits
- Memory is typically copied-on-write for efficiency
- Variables with the same names exist in both processes but are separate copies

** Process Execution: exec family
The =exec= family of functions replaces the current process image with a new one. Common variants:
- =execl()=: List of arguments
- =execv()=: Vector of arguments
- =execle()=: List of arguments and environment
- =execve()=: Vector of arguments and environment

Example:
#+begin_src c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("Child about to execute ls command...\n");
        execl("/bin/ls", "ls", "-l", NULL);
        // The following will only execute if execl fails
        perror("execl failed");
        return 1;
    } else if (pid > 0) {
        // Parent process
        printf("Parent created child with PID %d\n", pid);
    }
    
    return 0;
}
#+end_src

** Process Termination and Waiting
Processes terminate by:
- Returning from main
- Calling =exit()=
- Receiving certain signals (like SIGTERM)

Parents can wait for children using:
- =wait()=: Waits for any child
- =waitpid()=: Waits for a specific child

Example:
#+begin_src c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Child process
        printf("Child executing...\n");
        sleep(2);
        exit(42);  // Exit with status 42
    } else {
        // Parent process
        int status;
        printf("Parent waiting for child...\n");
        waitpid(pid, &status, 0);
        
        if (WIFEXITED(status)) {
            printf("Child exited with status %d\n", WEXITSTATUS(status));
        }
    }
    
    return 0;
}
#+end_src

** Zombie and Orphan Processes
- *Zombie process*: A child that has terminated but its parent hasn't called =wait()= to collect its exit status
- *Orphan process*: A child whose parent has terminated before it; adopted by the init process (PID 1)

* Threads
** What are threads?
Threads are "lightweight processes" that exist within a process. All threads within a process share:
- The same address space (code, data, heap)
- Open file descriptors
- Signal handlers

Each thread has its own:
- Thread ID
- Program counter
- Register set
- Stack

** Thread Creation: pthread_create()
POSIX threads (pthreads) is a standardized API for thread creation and synchronization.

Basic thread creation:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

void* thread_function(void* arg) {
    printf("Thread executing with argument: %s\n", (char*)arg);
    return NULL;
}

int main() {
    pthread_t thread;
    char* message = "Hello from main thread";
    
    // Create a new thread
    if (pthread_create(&thread, NULL, thread_function, message) != 0) {
        perror("Thread creation failed");
        return 1;
    }
    
    // Wait for thread to complete
    pthread_join(thread, NULL);
    printf("Thread joined\n");
    
    return 0;
}
#+end_src

** Thread Termination and Joining
Threads terminate by:
- Returning from the thread function
- Calling =pthread_exit()=
- The entire process exiting

Thread joining:
- =pthread_join()=: Wait for a thread to terminate
- =pthread_detach()=: Mark a thread as detached, resources automatically reclaimed

** Thread vs Process Advantages
*** Thread advantages:
- Faster creation and termination
- Easier sharing of data
- Lower memory overhead
- Faster context switching

*** Process advantages:
- Better isolation and protection
- Easier to implement
- More portable
- Crash of one process doesn't affect others

* Thread Synchronization
** The Need for Synchronization
When multiple threads access shared data, race conditions can occur, leading to inconsistent results. Synchronization mechanisms help ensure orderly access to shared resources.

** Race Condition Example
Consider a simple counter increment:
#+begin_src c
int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 1000; i++) {
        counter++; // This is not atomic!
    }
    return NULL;
}
#+end_src

The operation =counter++= actually involves three steps:
1. Read the current value of counter
2. Increment the value
3. Store the new value back

If two threads execute this concurrently, they might interleave these steps, leading to lost updates.

** Mutexes (Mutual Exclusion)
Mutexes ensure that only one thread can access a critical section at a time.

Basic mutex usage:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

int counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* increment(void* arg) {
    for (int i = 0; i < 1000; i++) {
        pthread_mutex_lock(&mutex);
        counter++;  // Critical section
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    
    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, increment, NULL);
    
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    
    printf("Final counter value: %d\n", counter);
    return 0;
}
#+end_src

** Condition Variables
Condition variables allow threads to wait until a specific condition occurs. They are used with mutexes.

Example:
#+begin_src c
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int ready = 0;

void* producer(void* arg) {
    pthread_mutex_lock(&mutex);
    
    // Do some work to produce data
    printf("Producer: Working...\n");
    sleep(2);
    
    // Set the condition and signal
    ready = 1;
    printf("Producer: Data is ready!\n");
    pthread_cond_signal(&cond);
    
    pthread_mutex_unlock(&mutex);
    return NULL;
}

void* consumer(void* arg) {
    pthread_mutex_lock(&mutex);
    
    // Wait until data is ready
    while (!ready) {
        printf("Consumer: Waiting for data...\n");
        pthread_cond_wait(&cond, &mutex);
    }
    
    // Process the data
    printf("Consumer: Processing data\n");
    
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;
    
    pthread_create(&cons_thread, NULL, consumer, NULL);
    sleep(1);  // Ensure consumer starts first
    pthread_create(&prod_thread, NULL, producer, NULL);
    
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);
    
    return 0;
}
#+end_src

** Semaphores
Semaphores are counters that control access to shared resources. They can be used for:
- Mutual exclusion (binary semaphore)
- Resource counting (counting semaphore)

Example:
#+begin_src c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_ITEMS 10
#define BUFFER_SIZE 5

sem_t empty;
sem_t full;
sem_t mutex;
int buffer[BUFFER_SIZE];
int in = 0, out = 0;

void* producer(void* arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        int item = i + 1;
        
        sem_wait(&empty);  // Wait for empty slot
        sem_wait(&mutex);  // Enter critical section
        
        buffer[in] = item;
        printf("Producer: Inserted item %d at position %d\n", item, in);
        in = (in + 1) % BUFFER_SIZE;
        
        sem_post(&mutex);  // Exit critical section
        sem_post(&full);   // Signal item produced
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        sem_wait(&full);   // Wait for an item
        sem_wait(&mutex);  // Enter critical section
        
        int item = buffer[out];
        printf("Consumer: Removed item %d from position %d\n", item, out);
        out = (out + 1) % BUFFER_SIZE;
        
        sem_post(&mutex);  // Exit critical section
        sem_post(&empty);  // Signal slot emptied
    }
    return NULL;
}

int main() {
    pthread_t prod_thread, cons_thread;
    
    sem_init(&empty, 0, BUFFER_SIZE);  // Buffer starts empty
    sem_init(&full, 0, 0);             // Buffer starts with no items
    sem_init(&mutex, 0, 1);            // Binary semaphore for CS
    
    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);
    
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);
    
    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&mutex);
    
    return 0;
}
#+end_src

** Deadlocks
Deadlocks occur when threads are blocked forever waiting for each other. The classic example is the dining philosophers problem.

Four conditions for deadlock:
1. Mutual exclusion: Resources that cannot be shared
2. Hold and wait: A thread holds resources while waiting for others
3. No preemption: Resources cannot be forcibly taken away
4. Circular wait: A cycle of threads, each waiting for a resource held by the next

Example (deadlock-prone):
#+begin_src c
void* thread1_function(void* arg) {
    pthread_mutex_lock(&mutex1);
    sleep(1);  // Increases chance of deadlock
    pthread_mutex_lock(&mutex2);
    
    // Critical section
    
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2_function(void* arg) {
    pthread_mutex_lock(&mutex2);
    sleep(1);  // Increases chance of deadlock
    pthread_mutex_lock(&mutex1);
    
    // Critical section
    
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}
#+end_src

Deadlock prevention includes:
- Lock ordering (always acquire locks in the same order)
- Lock timeouts
- Deadlock detection
- Using lock-free data structures

* Inter-Process Communication (IPC)
** What is IPC?
IPC mechanisms allow processes to communicate and synchronize their actions. Unlike threads, processes don't share memory by default, so explicit IPC mechanisms are needed.

** Pipes
Pipes provide a one-way communication channel between related processes (typically parent and child).

Example:
#+begin_src c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];  // pipefd[0] is read end, pipefd[1] is write end
    pid_t pid;
    char message[] = "Hello from the parent!";
    char buffer[100];
    
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }
    
    pid = fork();
    
    if (pid == -1) {
        perror("fork");
        return 1;
    } else if (pid == 0) {  // Child process
        close(pipefd[1]);  // Close unused write end
        
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Child received: %s\n", buffer);
        
        close(pipefd[0]);
    } else {  // Parent process
        close(pipefd[0]);  // Close unused read end
        
        write(pipefd[1], message, strlen(message) + 1);
        
        close(pipefd[1]);
        wait(NULL);  // Wait for child to finish
    }
    
    return 0;
}
#+end_src

** Named Pipes (FIFOs)
Named pipes (FIFOs) allow communication between unrelated processes.

Example (writer):
#+begin_src c
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd;
    char message[] = "Hello via FIFO!";
    
    // Create the named pipe (FIFO)
    mkfifo("/tmp/myfifo", 0666);
    
    // Open the FIFO for writing
    fd = open("/tmp/myfifo", O_WRONLY);
    
    // Write to the FIFO
    write(fd, message, strlen(message) + 1);
    
    // Close the FIFO
    close(fd);
    
    return 0;
}
#+end_src

Example (reader):
#+begin_src c
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    int fd;
    char buffer[100];
    
    // Open the FIFO for reading
    fd = open("/tmp/myfifo", O_RDONLY);
    
    // Read from the FIFO
    read(fd, buffer, sizeof(buffer));
    printf("Received message: %s\n", buffer);
    
    // Close the FIFO
    close(fd);
    
    return 0;
}
#+end_src

** Message Queues
Message queues allow processes to send structured messages to each other.

Example:
#+begin_src c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>

// Message structure
struct msg_buffer {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key = ftok("progfile", 65);
    int msgid = msgget(key, 0666 | IPC_CREAT);
    struct msg_buffer message;
    
    // Sender
    message.msg_type = 1;
    strcpy(message.msg_text, "Hello from message queue!");
    msgsnd(msgid, &message, sizeof(message), 0);
    
    // Receiver (in real applications, this would be in a different process)
    msgrcv(msgid, &message, sizeof(message), 1, 0);
    printf("Received: %s\n", message.msg_text);
    
    // Destroy the message queue
    msgctl(msgid, IPC_RMID, NULL);
    
    return 0;
}
#+end_src

** Shared Memory
Shared memory allows multiple processes to access a common region of memory.

Example:
#+begin_src c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>
#include <unistd.h>

int main() {
    key_t key = ftok("shmfile", 65);
    int shmid = shmget(key, 1024, 0666|IPC_CREAT);
    char *str = (char*) shmat(shmid, NULL, 0);
    
    if (fork() == 0) {  // Child process
        sleep(1);  // Ensure parent writes first
        printf("Child read: %s\n", str);
        shmdt(str);
    } else {  // Parent process
        strcpy(str, "Hello from shared memory!");
        printf("Parent wrote message to shared memory\n");
        wait(NULL);  // Wait for child
        shmdt(str);
        shmctl(shmid, IPC_RMID, NULL);  // Destroy shared memory
    }
    
    return 0;
}
#+end_src

** Sockets
Sockets provide network and inter-process communication. They can be used for processes on the same machine (Unix domain sockets) or across different machines (Internet sockets).

*** Socket Types and Families
- *Socket Families*:
  - =AF_UNIX= (=AF_LOCAL=): Unix domain sockets for local IPC
  - =AF_INET=: IPv4 Internet protocols
  - =AF_INET6=: IPv6 Internet protocols
  
- *Socket Types*:
  - =SOCK_STREAM=: TCP - reliable, connection-oriented, byte stream
  - =SOCK_DGRAM=: UDP - unreliable, connectionless, datagrams

*** TCP Socket Programming
TCP provides reliable, ordered, error-checked delivery of a stream of bytes between applications running on hosts communicating via an IP network.

**** Basic TCP Server
#+begin_src c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);
    char buffer[BUFFER_SIZE];
    
    // Create socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // Set socket options (reuse address)
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, 
                   &opt, sizeof(opt)) < 0) {
        perror("setsockopt failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // Setup server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // Bind socket to address
    if (bind(server_fd, (struct sockaddr *)&server_addr, 
             sizeof(server_addr)) < 0) {
        perror("Bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // Listen for connections (backlog of 5)
    if (listen(server_fd, 5) < 0) {
        perror("Listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Server listening on port %d\n", PORT);
    
    while (1) {
        // Accept connection
        client_fd = accept(server_fd, (struct sockaddr *)&client_addr, 
                          &client_len);
        if (client_fd < 0) {
            perror("Accept failed");
            continue;
        }
        
        printf("Client connected from %s:%d\n",
               inet_ntoa(client_addr.sin_addr),
               ntohs(client_addr.sin_port));
        
        // Read and echo data
        while (1) {
            memset(buffer, 0, BUFFER_SIZE);
            int bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
            
            if (bytes_read <= 0) {
                break;  // Client disconnected
            }
            
            printf("Received: %s", buffer);
            send(client_fd, buffer, bytes_read, 0);
        }
        
        close(client_fd);
        printf("Client disconnected\n");
    }
    
    close(server_fd);
    return 0;
}
#+end_src

**** Basic TCP Client
#+begin_src c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock = 0;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    char input[BUFFER_SIZE];
    
    // Create socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // Setup server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    
    // Convert IPv4 address from text to binary
    if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
        perror("Invalid address");
        close(sock);
        exit(EXIT_FAILURE);
    }
    
    // Connect to server
    if (connect(sock, (struct sockaddr *)&server_addr, 
                sizeof(server_addr)) < 0) {
        perror("Connection failed");
        close(sock);
        exit(EXIT_FAILURE);
    }
    
    printf("Connected to server\n");
    printf("Type messages (type 'quit' to exit):\n");
    
    while (1) {
        printf("> ");
        fgets(input, BUFFER_SIZE, stdin);
        
        if (strncmp(input, "quit", 4) == 0) {
            break;
        }
        
        // Send message
        send(sock, input, strlen(input), 0);
        
        // Receive echo
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = recv(sock, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_read > 0) {
            printf("Server echo: %s", buffer);
        }
    }
    
    close(sock);
    return 0;
}
#+end_src

*** Handling Multiple Clients
There are several approaches to handle multiple clients concurrently:

**** 1. Multi-threaded Server
Create a new thread for each client connection:

#+begin_src c
#include <pthread.h>

void* handle_client(void* arg) {
    int client_fd = *(int*)arg;
    free(arg);
    char buffer[BUFFER_SIZE];
    
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        
        if (bytes_read <= 0) {
            break;
        }
        
        // Process and respond
        send(client_fd, buffer, bytes_read, 0);
    }
    
    close(client_fd);
    return NULL;
}

// In main server loop:
while (1) {
    int* client_fd_ptr = malloc(sizeof(int));
    *client_fd_ptr = accept(server_fd, (struct sockaddr *)&client_addr, 
                           &client_len);
    
    pthread_t thread;
    pthread_create(&thread, NULL, handle_client, client_fd_ptr);
    pthread_detach(thread);  // Let thread clean up when done
}
#+end_src

**** 2. Using select() for I/O Multiplexing
Handle multiple clients in a single process using =select()=:

#+begin_src c
#include <sys/select.h>

fd_set master_fds, read_fds;
int max_fd;

// Initialize
FD_ZERO(&master_fds);
FD_SET(server_fd, &master_fds);
max_fd = server_fd;

while (1) {
    read_fds = master_fds;  // Copy master set
    
    // Wait for activity on any socket
    if (select(max_fd + 1, &read_fds, NULL, NULL, NULL) < 0) {
        perror("select failed");
        break;
    }
    
    // Check for new connections
    if (FD_ISSET(server_fd, &read_fds)) {
        int new_fd = accept(server_fd, (struct sockaddr *)&client_addr, 
                           &client_len);
        if (new_fd >= 0) {
            FD_SET(new_fd, &master_fds);
            if (new_fd > max_fd) {
                max_fd = new_fd;
            }
        }
    }
    
    // Check each client for data
    for (int fd = 0; fd <= max_fd; fd++) {
        if (fd != server_fd && FD_ISSET(fd, &read_fds)) {
            char buffer[BUFFER_SIZE];
            int bytes_read = recv(fd, buffer, BUFFER_SIZE - 1, 0);
            
            if (bytes_read <= 0) {
                // Client disconnected
                close(fd);
                FD_CLR(fd, &master_fds);
            } else {
                // Echo back to client
                send(fd, buffer, bytes_read, 0);
            }
        }
    }
}
#+end_src

*** Advanced Socket Features

**** Socket Options
Common socket options using =setsockopt()=:

#+begin_src c
int opt = 1;

// Allow socket reuse (avoid "Address already in use")
setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

// Set send/receive timeouts
struct timeval timeout;
timeout.tv_sec = 5;  // 5 seconds
timeout.tv_usec = 0;
setsockopt(server_fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
setsockopt(server_fd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));

// Keep connections alive
setsockopt(server_fd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));
#+end_src

**** Non-blocking Sockets
Make sockets non-blocking for asynchronous I/O:

#+begin_src c
#include <fcntl.h>

// Method 1: Using fcntl
int flags = fcntl(socket_fd, F_GETFL, 0);
fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK);

// Method 2: Using ioctl (Linux)
#include <sys/ioctl.h>
int nonblock = 1;
ioctl(socket_fd, FIONBIO, &nonblock);
#+end_src

*** Application Protocols

**** HTTP Server Example
A simple HTTP server that serves static content:

#+begin_src c
void handle_http_request(int client_fd) {
    char buffer[BUFFER_SIZE];
    char response[BUFFER_SIZE];
    
    // Read HTTP request
    recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
    
    // Parse request (simplified - just check if GET)
    if (strncmp(buffer, "GET", 3) == 0) {
        char *path = strtok(buffer + 4, " ");
        
        if (strcmp(path, "/") == 0) {
            // Serve index page
            char *content = "<html><body><h1>Welcome!</h1></body></html>";
            snprintf(response, BUFFER_SIZE,
                    "HTTP/1.1 200 OK\r\n"
                    "Content-Type: text/html\r\n"
                    "Content-Length: %zu\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                    "%s", strlen(content), content);
        } else {
            // 404 Not Found
            char *content = "<html><body><h1>404 Not Found</h1></body></html>";
            snprintf(response, BUFFER_SIZE,
                    "HTTP/1.1 404 Not Found\r\n"
                    "Content-Type: text/html\r\n"
                    "Content-Length: %zu\r\n"
                    "Connection: close\r\n"
                    "\r\n"
                    "%s", strlen(content), content);
        }
        
        send(client_fd, response, strlen(response), 0);
    }
}
#+end_src

**** File Transfer Protocol
Example of transferring files over sockets:

Server (sends file):
#+begin_src c
void send_file(int client_fd, const char *filename) {
    int file_fd = open(filename, O_RDONLY);
    if (file_fd < 0) {
        char *error = "ERROR: File not found\n";
        send(client_fd, error, strlen(error), 0);
        return;
    }
    
    // Get file size
    struct stat file_stat;
    fstat(file_fd, &file_stat);
    
    // Send file size first
    size_t file_size = file_stat.st_size;
    send(client_fd, &file_size, sizeof(file_size), 0);
    
    // Send file contents
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read;
    
    while ((bytes_read = read(file_fd, buffer, BUFFER_SIZE)) > 0) {
        send(client_fd, buffer, bytes_read, 0);
    }
    
    close(file_fd);
}
#+end_src

Client (receives file):
#+begin_src c
void receive_file(int server_fd, const char *filename) {
    // Receive file size
    size_t file_size;
    recv(server_fd, &file_size, sizeof(file_size), 0);
    
    // Create output file
    int file_fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    
    // Receive file contents
    char buffer[BUFFER_SIZE];
    size_t total_received = 0;
    
    while (total_received < file_size) {
        ssize_t bytes_received = recv(server_fd, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) break;
        
        write(file_fd, buffer, bytes_received);
        total_received += bytes_received;
        
        // Progress indicator
        printf("\rReceived: %zu/%zu bytes (%.1f%%)", 
               total_received, file_size, 
               (double)total_received / file_size * 100);
        fflush(stdout);
    }
    printf("\n");
    
    close(file_fd);
}
#+end_src

*** Chat Application Example
A multi-client chat server using select():

#+begin_src c
typedef struct {
    int socket;
    char nickname[32];
    int active;
} Client;

Client clients[MAX_CLIENTS];

void broadcast_message(char *message, int sender_socket) {
    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (clients[i].active && clients[i].socket != sender_socket) {
            send(clients[i].socket, message, strlen(message), 0);
        }
    }
}

void handle_chat_message(int client_index) {
    char buffer[BUFFER_SIZE];
    char message[BUFFER_SIZE + 64];
    
    int bytes_read = recv(clients[client_index].socket, buffer, 
                         BUFFER_SIZE - 1, 0);
    
    if (bytes_read <= 0) {
        // Client disconnected
        if (clients[client_index].active) {
            snprintf(message, sizeof(message), 
                    "%s has left the chat\n", 
                    clients[client_index].nickname);
            broadcast_message(message, -1);
            
            close(clients[client_index].socket);
            clients[client_index].active = 0;
        }
        return;
    }
    
    buffer[bytes_read] = '\0';
    
    // Format and broadcast message
    snprintf(message, sizeof(message), "[%s]: %s", 
             clients[client_index].nickname, buffer);
    broadcast_message(message, clients[client_index].socket);
}
#+end_src

*** Unix Domain Sockets
For local inter-process communication:

#+begin_src c
// Server code
#include <stdio.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <string.h>

int main() {
    int server_fd, client_fd;
    struct sockaddr_un address;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    char *message = "Hello from server";
    
    // Create socket
    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    
    address.sun_family = AF_UNIX;
    strcpy(address.sun_path, "/tmp/socket");
    unlink("/tmp/socket");  // Remove if it already exists
    
    // Bind socket
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    
    // Listen for connections
    listen(server_fd, 3);
    
    // Accept connection
    client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
    
    // Read client message
    read(client_fd, buffer, 1024);
    printf("Client: %s\n", buffer);
    
    // Send response
    send(client_fd, message, strlen(message), 0);
    
    close(client_fd);
    close(server_fd);
    return 0;
}
#+end_src

*** Socket Programming Best Practices
1. **Error Handling**: Always check return values from socket functions
2. **Resource Management**: Close sockets when done
3. **Buffer Management**: Be careful with buffer sizes and null termination
4. **Protocol Design**: Design clear message formats and delimiters
5. **Security**: Validate all input, use encryption for sensitive data
6. **Scalability**: Consider using epoll (Linux) or kqueue (BSD) for thousands of connections
7. **Timeouts**: Set appropriate timeouts to avoid hanging connections
8. **Signal Handling**: Handle SIGPIPE for broken connections

*** Essential Patterns for Client-Server Applications

**** Interactive Text-Based Protocol
Many applications use a simple request-response pattern where the server sends prompts and the client responds:

#+begin_src c
// Server side - sending prompts and reading responses
void interact_with_client(int client_fd) {
    char buffer[1024];
    
    // Send a prompt
    const char *prompt = "Enter your choice (1-5): ";
    send(client_fd, prompt, strlen(prompt), 0);
    
    // Read response
    int bytes_read = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        // Process the response
        int choice = atoi(buffer);
        // Handle the choice...
    }
}

// Client side - reading prompts and sending responses
void interact_with_server(int server_fd) {
    char buffer[1024];
    char input[1024];
    
    while (1) {
        // Read prompt from server
        int bytes_read = recv(server_fd, buffer, sizeof(buffer) - 1, 0);
        if (bytes_read <= 0) break;
        
        buffer[bytes_read] = '\0';
        printf("%s", buffer);  // Display prompt
        
        // Get user input and send to server
        if (fgets(input, sizeof(input), stdin)) {
            send(server_fd, input, strlen(input), 0);
        }
    }
}
#+end_src

**** Handling Line-Based Input
When working with text protocols, properly handling newlines is crucial:

#+begin_src c
// Remove trailing newline from fgets input
char *line = fgets(buffer, sizeof(buffer), stdin);
if (line) {
    size_t len = strlen(line);
    if (len > 0 && line[len-1] == '\n') {
        line[len-1] = '\0';  // Remove newline
    }
}

// Server side - clean up received input
int bytes = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
if (bytes > 0) {
    buffer[bytes] = '\0';
    // Remove trailing newline if present
    if (bytes > 0 && buffer[bytes-1] == '\n') {
        buffer[bytes-1] = '\0';
    }
}
#+end_src

**** Multi-Client Server with Threads
Simple pattern for handling multiple clients concurrently:

#+begin_src c
// Client data structure
typedef struct {
    int socket;
    // Add any per-client state here
} ClientData;

// Thread function to handle one client
void* handle_client_thread(void* arg) {
    ClientData *client = (ClientData*)arg;
    
    // Handle all interactions with this client
    // ... your protocol implementation ...
    
    // Cleanup
    close(client->socket);
    free(client);
    return NULL;
}

// Main server loop
int main() {
    int server_fd = /* create and setup server socket */;
    
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        
        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &addr_len);
        if (client_fd < 0) {
            perror("accept");
            continue;
        }
        
        // Create client data
        ClientData *client = malloc(sizeof(ClientData));
        client->socket = client_fd;
        
        // Create thread to handle client
        pthread_t thread;
        pthread_create(&thread, NULL, handle_client_thread, client);
        pthread_detach(thread);  // Don't need to join
    }
}
#+end_src

**** Common Socket Errors and Solutions

**Address Already in Use**
When restarting a server quickly:
#+begin_src c
int opt = 1;
setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
#+end_src

**Broken Pipe**
When writing to a disconnected socket:
#+begin_src c
// Ignore SIGPIPE globally
signal(SIGPIPE, SIG_IGN);

// Or use MSG_NOSIGNAL flag
send(socket, buffer, length, MSG_NOSIGNAL);
#+end_src

**Connection Refused**
Client trying to connect when server isn't running:
#+begin_src c
if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
    if (errno == ECONNREFUSED) {
        fprintf(stderr, "Server is not running on port %d\n", port);
    }
}
#+end_src

* Common Concurrency Patterns
** Producer-Consumer
The producer-consumer pattern involves two types of threads/processes:
- Producers generate data
- Consumers process the data

A bounded buffer is used to transfer data between them, with synchronization to ensure the buffer doesn't overflow or underflow.

** Reader-Writer
The reader-writer pattern allows multiple threads to read simultaneously, but requires exclusive access for writing. Used when reads are more common than writes.

** Thread Pool
A thread pool maintains a set of worker threads ready to execute tasks. This avoids the overhead of creating and destroying threads for each task.

Example:
#+begin_src c
// Simplified thread pool example
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

#define POOL_SIZE 3
#define QUEUE_SIZE 10

// Task structure
typedef struct {
    void (*function)(void*);
    void* argument;
} Task;

// Thread pool structure
typedef struct {
    Task taskQueue[QUEUE_SIZE];
    int front, rear, count;
    pthread_t workers[POOL_SIZE];
    pthread_mutex_t queueMutex;
    pthread_cond_t queueNotEmpty;
    pthread_cond_t queueNotFull;
    int shutdown;
} ThreadPool;

ThreadPool* pool;

// Worker thread function
void* worker(void* arg) {
    while (1) {
        pthread_mutex_lock(&pool->queueMutex);
        
        // Wait for work if queue is empty
        while (pool->count == 0 && !pool->shutdown) {
            pthread_cond_wait(&pool->queueNotEmpty, &pool->queueMutex);
        }
        
        // Exit if shutting down and queue is empty
        if (pool->shutdown && pool->count == 0) {
            pthread_mutex_unlock(&pool->queueMutex);
            pthread_exit(NULL);
        }
        
        // Get task from queue
        Task task = pool->taskQueue[pool->front];
        pool->front = (pool->front + 1) % QUEUE_SIZE;
        pool->count--;
        
        // Signal that queue is not full anymore
        pthread_cond_signal(&pool->queueNotFull);
        pthread_mutex_unlock(&pool->queueMutex);
        
        // Execute task
        (*(task.function))(task.argument);
    }
    
    return NULL;
}

// Initialize thread pool
void threadPoolInit() {
    pool = (ThreadPool*)malloc(sizeof(ThreadPool));
    pool->front = pool->rear = pool->count = 0;
    pool->shutdown = 0;
    
    pthread_mutex_init(&pool->queueMutex, NULL);
    pthread_cond_init(&pool->queueNotEmpty, NULL);
    pthread_cond_init(&pool->queueNotFull, NULL);
    
    // Create worker threads
    for (int i = 0; i < POOL_SIZE; i++) {
        pthread_create(&pool->workers[i], NULL, worker, NULL);
    }
}

// Add task to thread pool
void threadPoolAdd(void (*function)(void*), void* argument) {
    pthread_mutex_lock(&pool->queueMutex);
    
    // Wait if queue is full
    while (pool->count == QUEUE_SIZE) {
        pthread_cond_wait(&pool->queueNotFull, &pool->queueMutex);
    }
    
    // Add task to queue
    Task task = {function, argument};
    pool->taskQueue[pool->rear] = task;
    pool->rear = (pool->rear + 1) % QUEUE_SIZE;
    pool->count++;
    
    // Signal that queue is not empty
    pthread_cond_signal(&pool->queueNotEmpty);
    pthread_mutex_unlock(&pool->queueMutex);
}

// Shutdown thread pool
void threadPoolShutdown() {
    pthread_mutex_lock(&pool->queueMutex);
    pool->shutdown = 1;
    pthread_mutex_unlock(&pool->queueMutex);
    
    // Wake up all worker threads
    pthread_cond_broadcast(&pool->queueNotEmpty);
    
    // Wait for all worker threads to finish
    for (int i = 0; i < POOL_SIZE; i++) {
        pthread_join(pool->workers[i], NULL);
    }
    
    // Clean up
    pthread_mutex_destroy(&pool->queueMutex);
    pthread_cond_destroy(&pool->queueNotEmpty);
    pthread_cond_destroy(&pool->queueNotFull);
    
    free(pool);
}
#+end_src

* Best Practices
** General Concurrency Guidelines
1. Keep critical sections small
2. Minimize shared data
3. Use higher-level abstractions when possible
4. Understand and avoid race conditions
5. Use thread-safe functions
6. Be aware of deadlocks
7. Prefer message passing over shared memory when appropriate
8. Test extensively with different timing and orderings

** Debugging Concurrent Programs
Debugging concurrent programs is challenging because:
- Bugs may be non-deterministic
- Traditional debugging can change timing and hide issues
- Race conditions can be difficult to reproduce

Techniques:
- Use logging with thread/process IDs
- Use tools like Valgrind, ThreadSanitizer, Helgrind
- Write deterministic tests
- Use assertions to check invariants

** Performance Considerations
1. Too many threads can lead to thrashing (context switching overhead)
2. Thread affinity can improve cache utilization
3. Understand the cost of synchronization
4. Consider the granularity of parallelism
5. Be aware of false sharing (when threads compete for the same cache line)

* Footnotes
[fn:1] POSIX (Portable Operating System Interface) is a family of standards for maintaining compatibility between operating systems. POSIX threading (pthreads) is the standardized threading API.

[fn:2] Compiling threaded programs in Linux requires linking with the pthread library: `gcc -pthread program.c -o program`