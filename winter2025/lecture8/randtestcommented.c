// PEDAGOGICAL PURPOSE:
// This program demonstrates the behavior of the rand() random number generator.
// Key learning objectives:
// 1. Understanding that rand() generates pseudo-random numbers
// 2. Without srand(), the sequence is the SAME every time
// 3. Observing deterministic "randomness"
// 4. Why programs need to seed the random number generator
// 5. The difference between pseudo-random and truly random
// 6. Demonstrating the need for srand(time(NULL)) in real programs

#include <stdlib.h>      // Contains rand() and srand()
#include <stdio.h>

int main(){
  // GENERATE AND PRINT 10 RANDOM NUMBERS:
  for(int i=0;i<10;i++){
    // LOOP 10 TIMES:
    // i = 0, 1, 2, ..., 9

    // GENERATE RANDOM NUMBER:
    printf("Here's a random number %d\n",rand());
    // rand() returns a pseudo-random integer
    // Range: 0 to RAND_MAX (typically 2147483647 = 2^31-1)
    //
    // PSEUDO-RANDOM:
    // - Not truly random
    // - Generated by a deterministic algorithm (PRNG)
    // - Sequence depends on initial "seed" value
    // - Same seed → same sequence every time
    //
    // DEFAULT SEED:
    // Without calling srand(), the seed is implicitly 1
    // So every run produces the SAME sequence!
    //
    // WHY IS THIS BAD?
    // - Games would be identical every time
    // - Simulations would give same results
    // - Security applications would be predictable
    // - No actual randomness for testing
  }

  // PROGRAM EXITS:
  return 0;
}

// EXECUTION TRACE:
//
// Run 1:
// Time    Action                          Output
// ----    ------                          ------
// T0      main() starts
// T1      i=0, call rand()                "Here's a random number 1804289383"
// T2      i=1, call rand()                "Here's a random number 846930886"
// T3      i=2, call rand()                "Here's a random number 1681692777"
// ...
// T10     i=9, call rand()                "Here's a random number ..."
// T11     return 0
//
// Run 2 (same program, same machine):
// T0      main() starts
// T1      i=0, call rand()                "Here's a random number 1804289383"  ← SAME!
// T2      i=1, call rand()                "Here's a random number 846930886"   ← SAME!
// T3      i=2, call rand()                "Here's a random number 1681692777"  ← SAME!
// ...
// ALL VALUES ARE IDENTICAL TO RUN 1!

// EXPECTED OUTPUT (will be the same every time):
// Here's a random number 1804289383
// Here's a random number 846930886
// Here's a random number 1681692777
// Here's a random number 1714636915
// Here's a random number 1957747793
// Here's a random number 424238335
// Here's a random number 719885386
// Here's a random number 1649760492
// Here's a random number 596516649
// Here's a random number 1189641421
//
// Note: Exact values depend on your system's rand() implementation
// But they'll be THE SAME every time you run this program!

// CONCEPTUAL EXPLANATION:
//
// WHAT IS rand()?
// rand() is a Pseudo-Random Number Generator (PRNG)
// It uses a mathematical formula to generate numbers
// that "look" random but are actually deterministic
//
// HOW PRNG WORKS (simplified):
// 1. Start with a "seed" value (initial state)
// 2. Apply a mathematical function to get next number
// 3. Update internal state
// 4. Repeat for each rand() call
//
// TYPICAL ALGORITHM (Linear Congruential Generator):
// next = (a * current + c) % m
// Where a, c, m are carefully chosen constants
// Each call updates 'current' and returns it
//
// WHY DETERMINISTIC?
// Same seed → same sequence
// This is actually useful for:
// - Reproducible testing
// - Debugging (same random behavior every run)
// - Certain simulations
//
// WHY BAD FOR GAMES?
// Without seeding:
// - Every game plays out the same way
// - Players would memorize the "random" events
// - No replay value

// THE SEEDING PROBLEM:
//
// DEFAULT SEED = 1:
// C standard says: "If rand() is called before srand(),
// the sequence shall be the same as if srand(1) had been called."
//
// THIS MEANS:
// Every program starts with seed = 1
// Every program generates the same sequence
//
// THE SOLUTION:
// Call srand() with a varying value before calling rand()
//
// COMMON APPROACH:
// srand(time(NULL));
// - time(NULL) returns current time in seconds since epoch
// - Different every second, so different seed
// - Different seed → different sequence
//
// IMPROVED VERSION:
// srand(time(NULL));
// for (int i = 0; i < 10; i++) {
//     printf("Here's a random number %d\n", rand());
// }
// Now each run produces different numbers!

// PRNG STATE:
//
// INTERNAL STATE:
// rand() maintains hidden state (typically a single integer)
// Each call updates this state and returns a value derived from it
//
// SHARED STATE:
// All rand() calls in the program share the same state
// The state is global to the program
//
// RESETTING STATE:
// srand(seed) resets the state to a new starting value
// Same seed → same sequence again
//
// EXAMPLE:
// srand(42);
// int a = rand();  // Get first number with seed 42
// srand(42);       // Reset to same seed
// int b = rand();  // Get first number again
// // a == b (same seed, same first number)

// RAND() CHARACTERISTICS:
//
// RANGE:
// 0 to RAND_MAX (inclusive)
// RAND_MAX is at least 32767 (2^15-1)
// Often 2147483647 (2^31-1) on modern systems
//
// DISTRIBUTION:
// Uniform distribution (all values equally likely)
// Well, approximately - PRNGs aren't perfect
//
// QUALITY:
// rand() is not cryptographically secure
// Don't use for:
// - Passwords
// - Encryption keys
// - Security tokens
// Use /dev/urandom or cryptographic libraries instead
//
// GOOD FOR:
// - Games
// - Simulations
// - Testing
// - Non-critical randomness

// GETTING NUMBERS IN A RANGE:
//
// rand() gives 0 to RAND_MAX
// To get 0 to N-1:
//   rand() % N
//
// To get 1 to N:
//   rand() % N + 1
//
// To get MIN to MAX:
//   rand() % (MAX - MIN + 1) + MIN
//
// EXAMPLE:
// Dice roll (1-6):
//   int roll = rand() % 6 + 1;
//
// Coin flip (0 or 1):
//   int coin = rand() % 2;
//
// Note: Using modulo introduces slight bias
// For unbiased random, use more sophisticated methods

// WHY THIS PROGRAM?
//
// PEDAGOGICAL VALUE:
// This program demonstrates a common beginner mistake:
// Forgetting to seed the random number generator
//
// SYMPTOMS:
// - "Random" events happen the same way every time
// - Game is identical on every playthrough
// - "Why is my shuffle always the same?"
//
// THE LESSON:
// Always call srand(time(NULL)) before using rand()
// (Unless you want reproducible randomness for testing)

// COMMON QUESTIONS:
//
// Q: Why are the numbers the same every time?
// A: Because rand() uses a fixed seed (1) by default.
//    Call srand(time(NULL)) to get different sequences.
//
// Q: Are the numbers truly random?
// A: No! They're pseudo-random - generated by an algorithm.
//    Good enough for games and simulations, not cryptography.
//
// Q: Can I get the same sequence twice?
// A: Yes! Use srand() with the same seed:
//    srand(12345);  // Always produces same sequence
//
// Q: How do I get random floats or doubles?
// A: Divide by RAND_MAX:
//    double r = (double)rand() / RAND_MAX;  // 0.0 to 1.0
//
// Q: Is rand() thread-safe?
// A: No! Use rand_r() for thread safety, or better yet,
//    use C11's random number facilities.
//
// Q: What if I call srand() repeatedly?
// A: Each srand() resets the sequence.
//    Don't call it in a loop - call once at program start.

// BETTER ALTERNATIVES:
//
// FOR GAMES/SIMULATIONS:
// #include <time.h>
// srand(time(NULL));
// int r = rand();
//
// FOR BETTER QUALITY:
// Use random() instead of rand() (on Unix)
// Or use C11 <random> facilities
// Or use C++11 <random> library
//
// FOR CRYPTOGRAPHY:
// Use /dev/urandom (Unix)
// Use CryptGenRandom (Windows)
// Use dedicated crypto libraries
//
// FOR MODERN C++:
// #include <random>
// std::random_device rd;
// std::mt19937 gen(rd());
// std::uniform_int_distribution<> dis(1, 6);
// int roll = dis(gen);

// REPRODUCIBLE RANDOMNESS:
//
// USEFUL FOR DEBUGGING:
// Sometimes you WANT the same sequence:
// - Testing game logic
// - Reproducing bugs
// - Comparing algorithm performance
//
// HOW:
// srand(FIXED_SEED);
// Now every run is identical
//
// EXAMPLE:
// srand(42);  // Always use seed 42 for testing
// // Run test with known random sequence
//
// PRODUCTION VS TESTING:
// #ifdef DEBUG
//   srand(42);        // Fixed seed for testing
// #else
//   srand(time(NULL)); // Variable seed for production
// #endif

// TRY IT:
// Compile: gcc randtest.c -o randtest
// Run: ./randtest
//
// Run it multiple times:
// $ ./randtest
// $ ./randtest
// $ ./randtest
//
// Observe: THE NUMBERS ARE IDENTICAL EVERY TIME!
//
// Experiments:
// 1. Run it 5 times and note the output is always the same
//
// 2. Add srand(time(NULL)) before the loop:
//    #include <time.h>
//    ...
//    srand(time(NULL));
//    for (int i = 0; i < 10; i++) { ... }
//    Now each run gives different numbers!
//
// 3. Use a fixed seed:
//    srand(12345);
//    Run multiple times - same sequence each time
//
// 4. Generate numbers in a range:
//    int dice = rand() % 6 + 1;  // 1-6
//    printf("Dice roll: %d\n", dice);
//
// 5. Compare with and without seeding:
//    First run without srand()
//    Then add srand(time(NULL))
//    See the difference!
//
// 6. Print RAND_MAX:
//    printf("RAND_MAX = %d\n", RAND_MAX);
//    See the maximum value rand() can return
