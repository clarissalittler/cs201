// PEDAGOGICAL PURPOSE:
// This program successfully handles SIGTSTP (Ctrl+Z) to prevent being stopped.
// Key learning objectives:
// 1. SIGTSTP (not SIGSTOP) is sent by Ctrl+Z
// 2. SIGTSTP CAN be caught with a signal handler
// 3. Installing a handler for SIGTSTP overrides the default stop behavior
// 4. The difference between SIGSTOP (uncatchable) and SIGTSTP (catchable)
// 5. Why programs might want to prevent Ctrl+Z (during critical operations)
// 6. How to make a program immune to Ctrl+Z
// 7. Contrast with stopTest.c which tried (unsuccessfully) to block SIGSTOP

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>      // Contains sleep(), getpid()
#include <signal.h>      // Contains signal(), SIGTSTP

// SIGNAL HANDLER FOR SIGTSTP:
// Called when user presses Ctrl+Z
void handler(int sig){
  // PARAMETER: sig
  // Will be SIGTSTP (signal number 20 on most systems)

  // TAUNT THE USER:
  printf("Mwhahaha\n");
  // Evil laugh - mocking the user's attempt to stop us
  // Program refuses to be stopped by Ctrl+Z
  //
  // WHAT THIS DEMONSTRATES:
  // By installing a handler, we override the default SIGTSTP behavior
  // Default: Stop the process
  // Our handler: Print message and return (process continues)
  //
  // AFTER THIS HANDLER RETURNS:
  // Execution resumes where it was interrupted
  // Usually in the sleep() call
  // Main loop continues printing "Here I am!"

  // NOTE ON SAFETY:
  // printf() is not async-signal-safe
  // For production code, should use write():
  //   write(1, "Mwhahaha\n", 9);
  // But for this demo, printf() works fine
}

int main(){

  // INSTALL SIGTSTP HANDLER:
  signal(SIGTSTP,handler);
  // Associates SIGTSTP with our handler function
  //
  // WHAT THIS DOES:
  // - Overrides default SIGTSTP behavior (stop process)
  // - When Ctrl+Z is pressed, handler() is called instead
  // - handler() prints message and returns
  // - Process continues running (not stopped!)
  //
  // SIGTSTP vs SIGSTOP:
  // SIGTSTP = Terminal Stop (Ctrl+Z) - CAN be caught
  // SIGSTOP = Unconditional Stop - CANNOT be caught
  //
  // WHY THIS WORKS:
  // Ctrl+Z sends SIGTSTP (not SIGSTOP)
  // SIGTSTP is catchable, so we can override it
  //
  // WHAT DOESN'T WORK:
  // kill -STOP <pid> sends SIGSTOP
  // SIGSTOP cannot be caught or blocked
  // Process will stop regardless of our handler

  // INFINITE LOOP:
  while(1){
    // Run forever (or until killed with SIGKILL)

    // PRINT STATUS:
    printf("Here I am!: %d\n",getpid());
    // Show we're running and display PID
    // Demonstrates that Ctrl+Z doesn't stop us
    // PID allows testing with 'kill -STOP' from another terminal

    // WAIT:
    sleep(1);
    // Pause for 1 second
    // Makes output readable
    // Gives user time to try Ctrl+Z
    // When SIGTSTP arrives during sleep, sleep is interrupted
    // Handler runs, then sleep may return early or continue
  }

  // UNREACHABLE CODE:
  return 0;
  // Never reached because of infinite loop
  // Only way to exit:
  // - SIGKILL (kill -9)
  // - SIGTERM (if we don't handle it)
  // - Other unhandled fatal signals
}

// EXECUTION TRACE:
//
// Terminal:
// $ gcc stopTest2.c -o stopTest2
// $ ./stopTest2
// Here I am!: 12345
// Here I am!: 12345
// Here I am!: 12345
// [User presses Ctrl+Z]
// ^Z
// Mwhahaha
// Here I am!: 12345      ← Process continues! Not stopped!
// Here I am!: 12345
// [User presses Ctrl+Z again]
// ^Z
// Mwhahaha
// Here I am!: 12345      ← Still running!
// [User presses Ctrl+C]
// ^C
// [Process dies - SIGINT not handled]
//
// OR:
// [In another terminal]
// $ kill -STOP 12345
// [Process stops despite handler - SIGSTOP can't be caught]
//
// $ fg
// Here I am!: 12345      ← Resumes after being stopped by SIGSTOP

// EXPECTED BEHAVIOR:
//
// WITH Ctrl+Z:
// - User presses Ctrl+Z
// - Terminal sends SIGTSTP to foreground process group
// - Our handler is called
// - Handler prints "Mwhahaha"
// - Handler returns
// - Process continues (NOT stopped)
// - Loop continues printing
//
// WITH kill -STOP:
// - User sends kill -STOP <pid>
// - Kernel sends SIGSTOP
// - SIGSTOP cannot be caught
// - Process stops unconditionally
// - Handler is NOT called
// - Process remains stopped until SIGCONT

// CONCEPTUAL EXPLANATION:
//
// TERMINAL JOB CONTROL SIGNALS:
//
// SIGTSTP (Terminal Stop):
// - Generated by Ctrl+Z
// - TSTP = "Terminal SToP"
// - Catchable, blockable, ignorable
// - Default action: Stop the process
// - Can be overridden by handler (as we do here)
//
// SIGSTOP (Stop):
// - Generated by kill -STOP
// - Unconditional stop
// - CANNOT be caught, blocked, or ignored
// - Always stops the process
// - No handler can intercept it
//
// SIGCONT (Continue):
// - Resumes a stopped process
// - Generated by 'fg', 'bg', or kill -CONT
// - CAN be caught (handler runs when process resumes)
// - Process resumes regardless of handler
//
// WHY TWO STOP SIGNALS?
// SIGTSTP: Polite request from terminal (can be declined)
// SIGSTOP: Forceful command from system (cannot be declined)

// WHEN WOULD YOU WANT THIS?
//
// PREVENT ACCIDENTAL Ctrl+Z:
// 1. During critical operations:
//    - Database transaction in progress
//    - File being written
//    - Network connection active
//
// 2. Interactive applications:
//    - Games (Ctrl+Z would ruin game state)
//    - Text editors (might lose unsaved work)
//    - Media players (audio would be paused)
//
// 3. Security:
//    - Prevent user from suspending a critical daemon
//    - Ensure operation completes atomically
//
// EXAMPLE USE:
// void critical_section() {
//     signal(SIGTSTP, SIG_IGN);  // Ignore Ctrl+Z
//     // Do critical work
//     signal(SIGTSTP, SIG_DFL);  // Restore default
// }

// HANDLER OPTIONS FOR SIGTSTP:
//
// 1. IGNORE IT (this program):
//    void handler(int sig) { printf("Nice try!\n"); }
//    Process continues, Ctrl+Z has no effect
//
// 2. DEFER IT:
//    void handler(int sig) { stop_requested = 1; }
//    Main loop checks flag and stops at safe point
//
// 3. ASK USER:
//    void handler(int sig) {
//        printf("Really stop? (y/n): ");
//        if (getchar() == 'y') raise(SIGSTOP);
//    }
//    Confirm before actually stopping
//
// 4. COMPLETELY IGNORE:
//    signal(SIGTSTP, SIG_IGN);
//    Don't even run a handler, just discard signal

// SIGNAL DELIVERY:
//
// WHAT HAPPENS AT Ctrl+Z?
// 1. User presses Ctrl+Z
// 2. Terminal driver detects special character
// 3. Terminal sends SIGTSTP to foreground process group
// 4. Kernel checks if process has SIGTSTP handler
// 5. If yes: Calls handler
// 6. If no: Default action (stop process)
//
// IN THIS PROGRAM:
// Step 4: Yes, we have a handler
// Step 5: handler() is called, prints "Mwhahaha"
// Step 6: Handler returns, process continues

// BACKGROUND PROCESSES:
//
// INTERESTING FACT:
// Background processes receive SIGTSTP differently:
// - Ctrl+Z only affects foreground process group
// - Background jobs don't receive Ctrl+Z
// - But can still receive kill -TSTP <pid>
//
// TESTING:
// $ ./stopTest2 &        # Run in background
// [1] 12345
// Here I am!: 12345
// [Ctrl+Z does nothing - process is background]
// $ kill -TSTP 12345     # Send SIGTSTP directly
// Mwhahaha               # Handler runs!

// COMPARISON WITH stopTest.c:
//
// stopTest.c:
// - Tries to block SIGSTOP with sigprocmask()
// - Doesn't work (SIGSTOP can't be blocked)
// - Ctrl+Z still stops the process
// - Demonstrates a failed approach
//
// stopTest2.c:
// - Handles SIGTSTP with signal()
// - Works! (SIGTSTP can be caught)
// - Ctrl+Z doesn't stop the process
// - Shows the correct approach
//
// LESSON:
// To prevent Ctrl+Z, handle SIGTSTP (not SIGSTOP)

// LIMITATIONS:
//
// WHAT THIS DOESN'T PREVENT:
// 1. kill -STOP <pid>
//    SIGSTOP is always delivered
//
// 2. kill -KILL <pid> (kill -9)
//    SIGKILL is always delivered
//
// 3. Other termination signals if not handled:
//    - SIGTERM (kill default)
//    - SIGINT (Ctrl+C)
//    - SIGHUP (terminal hangup)
//
// REALITY:
// System administrator can always control processes
// This is by design - prevents malicious unkillable programs

// COMMON QUESTIONS:
//
// Q: Why does Ctrl+Z work now but not in stopTest.c?
// A: stopTest.c tried to block SIGSTOP (which Ctrl+Z doesn't send).
//    This program handles SIGTSTP (which Ctrl+Z does send).
//
// Q: Can I make my program completely unstoppable?
// A: No. kill -STOP and kill -9 always work.
//    You can only prevent Ctrl+Z (SIGTSTP).
//
// Q: What if I don't want any handler, just ignore Ctrl+Z?
// A: signal(SIGTSTP, SIG_IGN);
//    Now Ctrl+Z is silently ignored (no handler, no message).
//
// Q: How do I restore normal Ctrl+Z behavior?
// A: signal(SIGTSTP, SIG_DFL);
//    SIG_DFL = default handler (stop the process).
//
// Q: Can I stop my own process from code?
// A: Yes! raise(SIGSTOP) or kill(getpid(), SIGSTOP)
//    Process stops until SIGCONT is received.

// REAL-WORLD EXAMPLES:
//
// VIM TEXT EDITOR:
// Handles SIGTSTP to save cursor position
// Then sends SIGSTOP to itself
// When resumed (SIGCONT), restores cursor position
//
// SHELLS (bash, zsh):
// Suspend foreground job with Ctrl+Z
// Resume with 'fg' (foreground) or 'bg' (background)
// 'jobs' command shows suspended jobs
//
// LONG-RUNNING TASKS:
// Prevent accidental Ctrl+Z during:
// - Database backups
// - Large file transfers
// - Compilation
// - Scientific simulations

// TRY IT:
// Compile: gcc stopTest2.c -o stopTest2
// Run: ./stopTest2
//
// Expected interaction:
// Here I am!: 12345
// Here I am!: 12345
// [Press Ctrl+Z]
// ^Z
// Mwhahaha
// Here I am!: 12345      ← Process continues!
// Here I am!: 12345
// [Press Ctrl+C to exit]
// ^C
// [Process terminates]
//
// Experiments:
// 1. Try Ctrl+Z multiple times:
//    Each time prints "Mwhahaha" but process keeps running
//
// 2. Try to stop it from another terminal:
//    $ kill -STOP <PID>
//    Process stops (SIGSTOP works)
//    $ fg
//    Process resumes
//
// 3. Try kill -9:
//    $ kill -9 <PID>
//    Process dies immediately (SIGKILL works)
//
// 4. Modify to ignore instead of handling:
//    signal(SIGTSTP, SIG_IGN);
//    Now Ctrl+Z does nothing (no message)
//
// 5. Add handler for SIGINT too:
//    signal(SIGINT, handler);
//    Now Ctrl+C also prints "Mwhahaha" instead of killing
//    (But you can still kill -9)
//
// 6. Restore default behavior after N times:
//    static int count = 0;
//    if (++count >= 3) signal(SIGTSTP, SIG_DFL);
//    After 3 Ctrl+Z attempts, the 4th one stops the process
//
// 7. Compare behavior with stopTest.c
//    stopTest.c: Ctrl+Z stops it
//    stopTest2.c: Ctrl+Z prints message, continues
