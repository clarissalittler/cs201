* Agenda 1/8/2025
** Online C compiler
https://www.onlinegdb.com/
*works in a pinch*^{tm}
** Sizes of data types
*** Different sizes of numbers
*** Is char signed or unsigned?
 Let's check!
*** A byte is the basic unit in C
** 2's complement redux
 -n has the bit representation of n with all bits flipped /then/ adding 1 and carrying (overflow ignoring carry)

 start from -1 and then subtract for every bit you flip to 0
** Pointer arithmetic
** Look at the pointers!
** Casting pointers
** Traversing an integer one byte at a time
*** What the...
** Big endian vs. little endian
*** Network byte order
** Modifying out bit munging program to floating point
Now let's test out our intuition for how things work
** Real numbers and cardinality
The real numbers aka the "real number line" is the open interval (-\inf,\inf) consisting of all numbers with arbitrary decimal points

the size of the real numbers = |N|^|N|
** IEE 754
Let's talk it out first:
32 bit 

1 bit sign

8 bits exponent

23 bits significand
--------------------

floating point number is:
(-1)^(sign bit) * 2^(|e|-127) * (1 + |m|)

The sign bit is interpreted as itself
The 8 bits of the exponent are read as an unsigned
integer

the 23 bits of the significand are interpreted as a sum of negative powers of 2

e.g. 10000000...0 (1 and 22 0s)
then this is (1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 ....)
1100000...0

(1 * 2^-1 + 1 * 2^-2 + 0*2^-3 + ....)


0 1000000 1100...0 => 1 * 2^(128 - 127) * (1 + 0.75) => 2^1 * 1.75 = 3.5

IF the exponent is all 0s AND the significand is NOT all 0s THEN the number becomes

(-1)^s * (2^-126) * |m|


** Posits
An alternative standard

Two parameters: the number of bits and the /maximum/ number of exponent bits

n = the total number
es = the max number of exponent bits

for our examples we'll pick n = 8, es = 2

b7 b6 b5 b4 b3 b2 b1 b0

b7 = the sign bit 0 means positive, 1 means negative
if the next bit is a 1 then continue reading bits until either you get to the end *or* you hit a 0
if the next bit is a 0 then continue reading bits until either you get to the end *or* you hit a 1

count that number of bits and call it "r"

if there are bits left over after counting the regime bits, count up to /es/ of them and those are the exponent bits (call this number e)

if there are bits left over after counting the exponent, those are the significand bits

if the first bit of the regime is 1:
(-1)^(sign bit) * 2^((r-1)*2^es) * 2^e * (1 + |m|)
if the first bit of the regime is 0: 
(-1)^(sign bit) * 2^(-r*2^es) * 2^e * (1 + |m|)

0 1110 11 1

sign bit is 0
r = 3
e = 3
|m| = 0.5

1 * 2^(2 * 2^2) * 2^3 * (1 + 0.5)
  = 256 * 8 * 1.5 = 2048 * 1.5 = 3072

0 0001 11 1
  = 2^(-3 * 2^2) * 2^3 * (1.5)
  = 2^-12 * 2^3 * 1.5 = 2^-9 * 1.5
  
